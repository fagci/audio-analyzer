<meta name="viewport" content="width=device-width, initial-scale=1">
<canvas id="cv"></canvas>
<br />
<label for=ig>Gain</label>
<input type="range" id="ig" min="0" max="10" step="0.1" />
<br />
<label for=ifreq>Freq</label>
<input type="range" id="ifreq" min=0 max=22000 step=100 />
<br />
<button id="st">Start</button>
<style>
    body {
        color: #fff;
        background: #222;
        display: flex;
        flex-flow: column;
        align-items: center;
    }

    * {
        box-sizing: border-box;
    }

    button {
        text-transform: uppercase;
        background: #282;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
    }

    #cv {
        width: 100%;
        height: 256px;
        background: #000;
        border-radius: 6px;
    }

    input {
        width: 100%
    }
</style>
<script>
    const ctx = cv.getContext("2d");
    const W = cv.width = cv.clientWidth;
    const H = cv.height = cv.clientHeight;

    let auCtx, analyser, osc, gain;
    let scaleX, scaleY, freqData;

    ifreq.addEventListener('touchmove', function () {
        osc.frequency.value = this.value;
    });

    ig.addEventListener('touchmove', function () {
        gain.gain.value = this.value;
    });

    ctx.textBaseline = 'top';

    ctx.lineWidth = 1;
    ctx.fillStyle = 'rgb(200, 200, 200)';

    function draw() {
        analyser.getByteFrequencyData(freqData);

        ctx.clearRect(0, 0, W, H);

        ctx.fillText('Freq:' + osc.frequency.value, 8, 4)
        ctx.fillText('Gain:' + gain.gain.value, 8, 16)

        /*
        ctx.strokeStyle = 'rgb(128, 128, 128)';
        ctx.beginPath();
        for (let i = 0, x = 0; i < freqData.length; i++, x += scaleX) {
            if ((i * auCtx.sampleRate / (freqData.length *2)) % 1000) {
                continue;
            }
            ctx.moveTo(x, 0);
            ctx.lineTo(x, H);
        }
        ctx.stroke();
        */

        ctx.strokeStyle = 'rgb(0, 200, 0)';
        ctx.beginPath();
        ctx.moveTo(0, H);

        for (let i = 0, x = 0; i < freqData.length; i++, x += scaleX) {
            ctx.lineTo(x, H - freqData[i] * scaleY);
        }

        ctx.stroke();
        requestAnimationFrame(draw);
    }

    st.addEventListener('click', function () {
        auCtx = new AudioContext();
        osc = auCtx.createOscillator();
        gain = auCtx.createGain();
        analyser = auCtx.createAnalyser();

        analyser.fftSize = 1024;

        osc.connect(gain);
        gain.connect(analyser);

        osc.frequency.value = ifreq.value;
        osc.type = 'sine';
        gain.gain.value = 4;
        osc.start();

        scaleX = W / analyser.frequencyBinCount;
        scaleY = H / 256;
        freqData = new Uint8Array(analyser.frequencyBinCount);
        draw();

        const handleSuccess = function (stream) {
            const source = auCtx.createMediaStreamSource(stream);
            source.connect(gain);
            draw();
        };

        navigator.mediaDevices.getUserMedia({audio: true, video: false})
            .then(handleSuccess);
    })
</script>
